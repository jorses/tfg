%---------------------------------------------------------------------
%
%                          Capï¿½tulo 2
%
%---------------------------------------------------------------------

\chapter{CBR : Implementation}

\begin{resumen}
In this chapter we outline the technical implementations of the CBR side of our program.
\end{resumen}

%-------------------------------------------------------------------
\section{Information Storage}
%-------------------------------------------------------------------
\label{cap1:sec:informationstorage}

Because the information we're storing is still low and the metrics are different for each domain the only way to consistenly store the information is through a non-relational database.
To provide the information to the experiment and to run this as a proof of concept we can simplify it by storing information in the form of JSON structures, which will be stored as files in a directory accessible by our program.
The relevant information for the use case at hand will be retrieved by our program, stored as a run time variable, modified when needed and then stored back to the JSON overwriting the previous structure.
If we had a non relational database we could simply update the database instead.

\section{Retrieve}
%-------------------------------------------------------------------
\label{cap1:sec:retrieve}

If we're doing a full non-relational database implementation it's probably better to develop a domainID, because that would allow us to have different domains with the same column names.
For the proof of concept though that is not an issue because we've made sure this hasn't happened with the datasets used for the testing.

Retrieving this information is as easy as reading the JSON file and loading into a dictionary type in Python. We know which information to retrieve because each json contains an ID variable with the column list of the datasets from the domain.
We do this with a file buffer the standard way. Once it has been loaded the information is handled by two different classes.

\section{Reuse}
%-------------------------------------------------------------------
\label{cap1:sec:reuse}

The objective information about the domain is loaded and handled by the class that handles the objective information, which will then be passed to the 
The profile or subjective information about the domain and user is handled by the module that handles the profiles, which will then pass it along to the module that generates the report.
This allows us to reuse the previous experiences in the process of generating the report module.

\section{Revise}
%-------------------------------------------------------------------
\label{cap1:sec:revise}
There are two ways on which we can revise the information. If the users from the start say what they want then the system associates what they want as if changes have been made to the report that was going to be presented to them.
In any case, when the users are provided with the report they can provide feedback through a visual interface by selecting which information is shown and shouldn't be shown, what information should be shown but is not the report, and change the colors/fonts of the report.
This allows us a thorough revise step, in which the user has full agency over the results generated by the program and is able to change all the choices that our system has made.
This is incredibly important because it makes our system learn a lot from each interaction.

\section{Retain}
%-------------------------------------------------------------------
\label{cap1:sec:retain}
Once these changes have been made the objective information is updated and written back to disk by the same module that retrieved it through an store method.
The same method is present in the module responsible for handling the profile information, which will update the choices the user has made.
This is a crucial step because it is what allows us to retrieve these changes consistenly if this user or a similar one wants to use the system in the future.
In the end what we've achieved is a system that grows better with each interaction, providing the users with better and easier use experiences every time they use it.

